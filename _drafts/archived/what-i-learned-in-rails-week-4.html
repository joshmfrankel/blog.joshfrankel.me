---
layout: post
title: "What I Learned in Rails Week 4"
---

Render partial as collection with aliased result variable. Renders partial for each record in the collection
<%= render partial: "shared/learning_library_statistics_detail_table_row", collection: presenter.detail_data_for_display, as: :record %>

polymorphic url
http://api.rubyonrails.org/classes/ActionDispatch/Routing/PolymorphicRoutes.html path
polymorphic_path([:show_detail, presenter.assignable])

HAVING VS WHERE
It is important to understand the interaction between aggregates and SQL's WHERE and HAVING clauses. The fundamental difference between WHERE and HAVING is this: WHERE selects input rows before groups and aggregates are computed (thus, it controls which rows go into the aggregate computation), whereas HAVING selects group rows after groups and aggregates are computed. Thus, the WHERE clause must not contain aggregate functions; it makes no sense to try to use an aggregate to determine which rows will be inputs to the aggregates. On the other hand, the HAVING clause always contains aggregate functions. (Strictly speaking, you are allowed to write a HAVING clause that doesn't use aggregates, but it's seldom useful. The same condition could be used more efficiently at the WHERE stage.)

Arel
http://www.slideshare.net/flah00/activerecord-arel
join_sources for subquery joinss

Clear fragment cache
Rails.cache.clear
